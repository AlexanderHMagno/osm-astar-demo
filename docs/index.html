<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Routing</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"
        integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
        crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"
        integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew=="
        crossorigin=""></script>

    <script src="a-star.js"></script>

    <style>
        #mapid {
            height: 90vh;
        }
    </style>
</head>
<body>

    <div id="mapid"></div>

    <div id="data">
        <div id="nodes">

        </div>
        <div>
            <button id="toggle-nodes">Toggle Nodes</button>
        </div>
    </div>

    <script>
       let ab = true;
let aid = -1;
let bid = -1;
const mymap = L.map('mapid').setView([47.5886000, 12.1804000], 16);
const line = L.polyline([], {color: 'red'}).addTo(mymap);
const a = L.marker([0, 0]).addTo(mymap);
const b = L.marker([1, 1]).addTo(mymap);

mymap.setMaxBounds([
    [47.5644000, 12.1487000],
    [47.6033000, 12.1898000]
]);

mymap.on('click', (e) => {
    let nn = nearestNeighbour(e.latlng["lat"], e.latlng["lng"]);

    if (ab) {
        a.setLatLng([nn.lat, nn.lng]);
        aid = nn.id;
        ab = false;
    } else {
        b.setLatLng([nn.lat, nn.lng]);
        bid = nn.id;
        ab = true;
    }

if (aid > 0 && bid > 0) {
    let result = dijkstra(aid, bid);
    if (result) {
        let path = constructPath(result.previous, bid);
        line.setLatLngs(path);

        let traversedNodes = Object.keys(result.previous).filter(nodeId => result.previous[nodeId] !== null);
        displayTraversedNodes(traversedNodes, 3000); // Display traversed nodes for 3 seconds
    }
}
});

L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
    attribution: '',
    maxZoom: 17,
    subdomains: "abc"
}).addTo(mymap);

fetch("map.json")
    .then(response => response.json())
    .then(data => {
        localStorage.setItem("data", JSON.stringify(data.nodes));

        let l = 0;
        for (let k in data.nodes) l++;

        document.getElementById('nodes').textContent = `${l} nodes in the map`;
    });

document.getElementById('toggle-nodes').addEventListener('click', toggleNodes);

let data;

function nearestNeighbour(lat, lon) {
    data = JSON.parse(localStorage.getItem('data'));
    let id = "";
    let gd = 99999999;

    for (let key in data) {
        let d = distance(lat, lon, data[key].lat, data[key].lon);

        if (d < gd) {
            gd = d;
            id = key;
        }
    }

    return {
        id: id,
        data: data[id],
        lat: data[id].lat,
        lng: data[id].lon
    };
}

function displayTraversedNodes(traversedNodes, duration) {
    let circles = [];
    for (let nodeId of traversedNodes) {
        let nodeCircle = L.circle([data[nodeId].lat, data[nodeId].lon], {radius: 1, color: 'red'}).addTo(mymap);
        circles.push(nodeCircle);
    }

    setTimeout(() => {
        for (let circle of circles) {
            mymap.removeLayer(circle);
        }
    }, duration);
}
function dijkstra(startId, goalId) {
    data = JSON.parse(localStorage.getItem('data'));

    let dist = {};
    let previous = {};
    let unvisited = new Set(Object.keys(data));

    for (let key in data) {
        dist[key] = Infinity;
        previous[key] = null;
    }
    dist[startId] = 0;

    while (unvisited.size > 0) {
        let currentId = getClosestNode(dist, unvisited);
        unvisited.delete(currentId);

        if (currentId == goalId) {
            return {previous: previous};
        }

        for (let neighbor of data[currentId].con) {
            let alt = dist[currentId] + distance(data[currentId].lat, data[currentId].lon, data[neighbor].lat, data[neighbor].lon);

            if (alt < dist[neighbor]) {
                dist[neighbor] = alt;
                
				                previous[neighbor] = currentId;
            }
        }
    }

    return null;
}

function constructPath(previous, goalId) {
    let path = [];
    let currentNode = goalId;

    while (currentNode) {
        path.unshift([data[currentNode].lat, data[currentNode].lon]);
        currentNode = previous[currentNode];
    }

    return path;
}

function getClosestNode(dist, unvisited) {
    let minDist = Infinity;
    let closestNode = null;

    for (let node of unvisited) {
        if (dist[node] < minDist) {
            minDist = dist[node];
            closestNode = node;
        }
    }

    return closestNode;
}

function distance(lat1, lon1, lat2, lon2) {
    let d1 = Math.abs(lat1 - lat2);
    let d2 = Math.abs(lon1 - lon2);
    return d1 + d2;
}


function toggleNodes() {
    let circles = [];

    if (!data) {
        data = JSON.parse(localStorage.getItem('data'));
    }

    for (let key in data) {
        if (data.hasOwnProperty(key)) circles.push(L.circle([data[key].lat, data[key].lon], {radius: 1}));
    }

    let circlesLayer = L.layerGroup(circles);

    if (mymap.hasLayer(circlesLayer)) {
        mymap.removeLayer(circlesLayer);
    } else {
        mymap.addLayer(circlesLayer);
    }
}


    </script>
</body>

</html>